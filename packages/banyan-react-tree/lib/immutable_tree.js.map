{"version":3,"sources":["../src/immutable_tree.ts"],"names":["node","Tree","data","root","create","ids","createIdMap","selected","toString","getChildren","hasChildren","parent","child","addNodeToRoot","addNodeToParent","name","found_node","getNodeByName","doGetNodeByName","n","removeNode","getReadonlyNode","new_root","affected_info","updateTree","changed_nodes","removed_nodes","map","removed_node","id","get","result","getNodeById","Error","updateNode","is_open","Boolean","t","deselect","is_selected","isNodeOpen","closeNode","openNode","attributes","update_info","tree","iterateTree","addNode","new_child","readonly_parent","concat","parents","getParents","is_root","current_node","parent_id","push","updated_nodes","deleted_ids","new_ids","updateIds","new_tree","createCopy","updates_node_map","merge","forEach","delete","iteratePairs"],"mappings":"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","file":"immutable_tree.js","sourcesContent":["import { List, Map } from \"immutable\";\n\nimport * as node from \"./immutable_node\";\nimport { Node, NodeId, INodeData, IReadonlyNode } from \"./immutable_node\";\n\nexport class Tree {\n    public root: Node;\n    private ids: Map<NodeId, Node>;\n    private selected: NodeId|null;\n\n    constructor(data: INodeData[] = []) {\n        this.root = node.create(data);\n        this.ids = createIdMap(this.root);\n\n        this.selected = null;\n    }\n\n    public toString(): string {\n        return node.toString(this.root);\n    }\n\n    public getChildren(): List<Node> {\n        return node.getChildren(this.root);\n    }\n\n    public hasChildren(): boolean {\n        return node.hasChildren(this.root);\n    }\n\n    // todo: reverse params\n    public addNode(parent: Node|INodeData, child?: INodeData): Tree {\n        if (!child) {\n            return this.addNodeToRoot(parent as INodeData);\n        }\n        else {\n            return this.addNodeToParent(parent as Node, child as INodeData);\n        }\n    }\n\n    public getNodeByName(name: string): Node|null {\n        const found_node = node.getNodeByName(this.root, name);\n\n        if (!found_node) {\n            return null;\n        }\n        else {\n            return found_node.node;\n        }\n    }\n\n    public doGetNodeByName(name: string): Node {\n        return node.doGetNodeByName(this.root, name).node;\n    }\n\n    public removeNode(n: Node): Tree {\n        const [new_root, affected_info] = node.removeNode(this.getReadonlyNode(n));\n\n        return this.updateTree(\n            new_root,\n            affected_info.changed_nodes,\n            affected_info.removed_nodes.map(removed_node => removed_node.id)\n        );\n    }\n\n    public getNodeById(id: NodeId): Node|null {\n        return this.ids.get(id);\n    }\n\n    public doGetNodeById(id: NodeId): Node {\n        const result = this.getNodeById(id);\n\n        if (!result) {\n            throw Error(`Node with id '${id} not found`);\n        }\n\n        return result;\n    }\n\n    public openNode(id: NodeId): Tree {\n        const n = this.getNodeById(id);\n\n        if (!n) {\n            return this;\n        }\n        else {\n            return this.updateNode(n, { is_open: true });\n        }\n    }\n\n    public closeNode(id: NodeId): Tree {\n        const n = this.getNodeById(id);\n\n        if (!n) {\n            return this;\n        }\n        else {\n            return this.updateNode(n, { is_open: false });\n        }\n    }\n\n    public isNodeOpen(id: NodeId): boolean {\n        const n = this.getNodeById(id);\n\n        if (!n) {\n            return false;\n        }\n        else {\n            return Boolean(n.is_open);\n        }\n    }\n\n    public selectNode(id: NodeId): Tree {\n        const t = this.deselect();\n        const n = t.getNodeById(id);\n\n        if (!n) {\n            return t;\n        }\n        else {\n            t.selected = id;\n            return t.updateNode(n, { is_selected: true });\n        }\n    }\n\n    public toggleNode(id: NodeId): Tree {\n        if (this.isNodeOpen(id)) {\n            return this.closeNode(id);\n        }\n        else {\n            return this.openNode(id);\n        }\n    }\n\n    public updateNode(n: Node, attributes: any): Tree {\n        const [new_root, update_info] = node.updateNode(\n            this.getReadonlyNode(n),\n            attributes\n        );\n\n        return this.updateTree(new_root, update_info.changed_nodes, []);\n    }\n\n    public openAllFolders(): Tree {\n        let tree: Tree = this;\n\n        for (const n of node.iterateTree(this.root)) {\n            tree = tree.openNode(n.id);\n        }\n\n        return tree;\n    }\n\n    public getSelectedNode(): Node|null {\n        if (!this.selected) {\n            return null;\n        }\n        else {\n            return this.getNodeById(this.selected);\n        }\n    }\n\n    private addNodeToRoot(child: INodeData): Tree {\n        const [new_root, update_info] = node.addNode(this.root, child);\n\n        return this.updateTree(new_root, [update_info.new_child], []);\n    }\n\n    private addNodeToParent(parent: Node, child: INodeData): Tree {\n        const readonly_parent = this.getReadonlyNode(parent);\n        const [new_root, update_info] = node.addNode(this.root, readonly_parent, child);\n\n        return this.updateTree(\n            new_root,\n            update_info.changed_nodes.concat([update_info.new_child]),\n            []\n        );\n    }\n\n    private getReadonlyNode(n: Node): IReadonlyNode {\n        return {\n            node: n,\n            parents: this.getParents(n)\n        };\n    }\n\n    private getParents(n: Node): Node[] {\n        if (n.is_root) {\n            return [];\n        }\n        else {\n            const parents: Node[] = [];\n            let current_node: Node|null = n;\n\n            while (current_node && current_node.parent_id) {\n                const parent: Node|null = this.getNodeById(current_node.parent_id);\n\n                if (parent) {\n                    parents.push(parent);\n                }\n\n                current_node = parent;\n            }\n\n            parents.push(this.root);\n\n            return parents;\n        }\n    }\n\n    private updateTree(new_root: Node, updated_nodes: Node[], deleted_ids: NodeId[]): Tree {\n        const new_ids = this.updateIds(updated_nodes, deleted_ids);\n\n        const new_tree = this.createCopy();\n\n        new_tree.ids = new_ids;\n        new_tree.root = new_root;\n\n        return new_tree;\n    }\n\n    private createCopy(): Tree {\n        const new_tree = new Tree();\n\n        new_tree.ids = this.ids;\n        new_tree.root = this.root;\n        new_tree.selected = this.selected;\n\n        return new_tree;\n    }\n\n    private updateIds(updated_nodes: Node[], deleted_ids: NodeId[]): Map<NodeId, Node> {\n        const updates_node_map = Map<NodeId, Node>(\n            updated_nodes.map(\n                (n: Node) => ([n.id, n])\n            )\n        );\n\n        let new_ids = this.ids.merge(updates_node_map);\n\n        deleted_ids.forEach(id => {\n            new_ids = new_ids.delete(id);\n        });\n\n        return new_ids;\n    }\n\n    private deselect(): Tree {\n        if (!this.selected) {\n            return this;\n        }\n        else {\n            const n = this.getNodeById(this.selected);\n\n            if (!n) {\n                return this;\n            }\n            else {\n                const new_tree = this.updateNode(n, { is_selected: false });\n                new_tree.selected = null;\n\n                return new_tree;\n            }\n        }\n    }\n}\n\nfunction createIdMap(root: Node): Map<NodeId, Node> {\n    function* iteratePairs() {\n        for (const n of node.iterateTree(root)) {\n            yield [n.id, n];\n        }\n    }\n\n    return Map<NodeId, Node>(iteratePairs());\n}\n"]}
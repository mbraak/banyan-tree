{"version":3,"sources":["../src/immutable_node.ts"],"names":["create","toString","nodeListToString","hasChildren","getChildren","iterateTree","getNodeByName","doGetNodeByName","addNode","removeNode","updateNode","iterateTreeWithParents","_Node","id","undefined","name","is_root","parent_id","children","is_open","is_selected","Node","createEmptyTree","createNodesFromData","children_data","map","createNodeFromData","node_data","createChildren","set","nodesToString","nodes","join","node","has_children","isEmpty","n","treeSeqPath","is_branch","get_children","root","walk","path","toArray","new_path","push","child","parents","treeSeq","include_root","readonly_node","reverse","result","Error","readonly_parent","child_data","addNodeToNonRoot","data","addNodeToRoot","parent","new_child","new_parent","addChild","updateParents","new_root","changed_nodes","concat","initial_old_child","intitial_new_child","old_child","new_parents","replaceChild","child_index","indexOf","new_children","readonly_child","removeNodeFromRoot","removeNodeFromParent","removeChild","removed_nodes","Array","from","changed_parents","delete","attributes","new_node","merge"],"mappings":"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","file":"immutable_node.js","sourcesContent":["import { List, Record } from \"immutable\";\n\nimport { first, last, dropRight, tail } from \"lodash\";\n\ndeclare module \"immutable\" {\n    // tslint:disable-next-line: interface-name\n    interface List<T> {\n        [Symbol.iterator](): IterableIterator<T>;\n    }\n}\n\ntype GetChildren = (node: Node) => List<Node>;\ntype IsBranch = (node: Node) => boolean;\n\nexport type NodeId = number|string;\n\nexport interface INodeData {\n    id: NodeId;\n    name: string;\n    children?: INodeData[];\n    load_on_demand?: boolean;\n}\n\nexport interface IReadonlyNode {\n    node: Node;\n    parents: Node[];\n}\n\nexport interface IRemoveInfo {\n    changed_nodes: Node[];\n    removed_nodes: Node[];\n}\n\nexport interface IUpdateInfo {\n    changed_nodes: Node[];\n}\n\nexport interface IAddInfo {\n    new_child: Node;\n    changed_nodes: Node[];\n}\n\nexport const _Node = Record({\n    id: undefined,\n    name: \"\",\n    is_root: false,\n    parent_id: undefined,\n    children: undefined,\n    is_open: false,\n    is_selected: false\n});\n\nexport class Node extends _Node {\n    public id: NodeId;\n    public name: string;\n    public is_root: boolean;\n    public parent_id: any;\n    public children: List<Node>;\n    public is_open: boolean;\n    public is_selected: boolean;\n}\n\nfunction createEmptyTree(): Node {\n    return new Node({ is_root: true });\n}\n\nfunction createNodesFromData(parent_id: NodeId|null, children_data: INodeData[]): List<Node> {\n    return List(\n        children_data.map(\n            node_data => createNodeFromData(parent_id, node_data)\n        )\n    );\n}\n\nfunction createNodeFromData(parent_id: NodeId|null, node_data: INodeData): Node {\n    function createChildren() {\n        if (!node_data.children) {\n            return null;\n        }\n        else {\n            return createNodesFromData(node_data.id, node_data.children);\n        }\n    }\n\n    return new Node(node_data)\n        .set(\"parent_id\", parent_id)\n        .set(\"children\", createChildren()) as Node;\n}\n\nexport function create(children_data?: INodeData[]): Node {\n    function createChildren(): List<Node> {\n        if (children_data) {\n            return createNodesFromData(null, children_data);\n        }\n        else {\n            return List<Node>();\n        }\n    }\n\n    return createEmptyTree()\n        .set(\"children\", createChildren()) as Node;\n}\n\nfunction nodesToString(nodes: List<Node>): string {\n    return nodes\n        .map(toString)\n        .join(\" \");\n}\n\nexport function toString(node: Node): string {\n    const children = node.children ? node.children : List<Node>();\n    const has_children = !children.isEmpty();\n\n    if (node.is_root) {\n        if (!has_children) {\n            return \"\";\n        }\n        else {\n            return nodesToString(children);\n        }\n    }\n    else if (!has_children) {\n        return node.name;\n    }\n    else {\n        return `${node.name}(${nodesToString(children)})`;\n    }\n}\n\nexport function nodeListToString(nodes: Node[]): string {\n    return nodes\n        .map(\n            n => {\n                if (n.is_root) {\n                    return \"[root]\";\n                }\n                else {\n                    return n.name;\n                }\n            }\n        )\n        .join(\" \");\n}\n\nexport function hasChildren(node: Node): boolean {\n    const { children } = node;\n\n    if (!children) {\n        return false;\n    }\n    else {\n        return !children.isEmpty();\n    }\n}\n\nexport function getChildren(node: Node): List<Node> {\n    if (node.children) {\n        return node.children;\n    }\n    else {\n        return List<Node>();\n    }\n}\n\n/* Iterates over tree. Return [node parents] pairs.\n  - generator\n  - walks depth-first\n*/\nfunction treeSeqPath(\n    is_branch: IsBranch, get_children: GetChildren, root: Node\n): Iterable<[Node, Node[]]> {\n    function* walk(path: List<Node>, node: Node): Iterable<[Node, Node[]]> {\n        yield [node, path.toArray()];\n\n        if (is_branch(node)) {\n            const children = get_children(node);\n            const new_path = path.push(node);\n\n            for (const child of children) {\n                yield* walk(new_path, child);\n            }\n        }\n    }\n\n    return walk(List<Node>(), root);\n}\n\n// Iterate tree; return lazy sequence of readonly nodes\n// - skip root\nfunction* iterateTreeWithParents(root: Node): Iterable<IReadonlyNode> {\n    for (const [node, parents] of treeSeqPath(hasChildren, getChildren, root)) {\n        if (node !== root) {\n            yield { node, parents };\n        }\n    }\n}\n\nfunction treeSeq(is_branch: IsBranch, get_children: GetChildren, root: Node): Iterable<Node> {\n    function* walk(node: Node): Iterable<Node> {\n        yield node;\n\n        if (is_branch(node)) {\n            const children = get_children(node);\n\n            for (const child of children) {\n                yield* walk(child);\n            }\n        }\n    }\n\n    return walk(root);\n}\n\nexport function* iterateTree(root: Node, include_root: boolean = false): Iterable<Node> {\n    if (include_root) {\n        yield* treeSeq(hasChildren, getChildren, root);\n    }\n    else {\n        for (const node of treeSeq(hasChildren, getChildren, root)) {\n            if (node !== root) {\n                yield node;\n            }\n        }\n    }\n}\n\n// Find node by name; return readonly node or nil\nexport function getNodeByName(root: Node, name: string): IReadonlyNode|null {\n    for (const readonly_node of iterateTreeWithParents(root)) {\n        if (readonly_node.node.name === name) {\n            const { node, parents } = readonly_node;\n\n            return {\n                node,\n                parents: parents.reverse()\n            };\n        }\n    }\n\n    return null;\n}\n\nexport function doGetNodeByName(root: Node, name: string): IReadonlyNode {\n    const result = getNodeByName(root, name);\n\n    if (!result) {\n        throw Error(`Node ${name} not found`);\n    }\n\n    return result;\n}\n\n// Add node\n//  - return [new-root {new-child changed-nodes}]\nexport function addNode(root: Node, readonly_parent: any, child_data?: any): [Node, IAddInfo] {\n    if (child_data) {\n        return addNodeToNonRoot(readonly_parent, new Node(child_data));\n    }\n    else {\n        const data = readonly_parent;\n        return addNodeToRoot(root, new Node(data));\n    }\n}\n\nfunction addNodeToNonRoot(readonly_parent: IReadonlyNode, child: Node): [Node, IAddInfo] {\n    const parent = readonly_parent.node;\n    const new_child = child.set(\"parent_id\", parent.id) as Node;\n    const new_parent = addChild(parent, new_child);\n    const [new_root, changed_nodes] = updateParents(parent, new_parent, readonly_parent.parents);\n\n    return [\n        new_root,\n        {\n            new_child,\n            changed_nodes: [new_parent].concat(changed_nodes)\n        }\n    ];\n}\n\nfunction addNodeToRoot(root: Node, child: Node): [Node, IAddInfo] {\n    const new_root = addChild(root, child);\n\n    return [\n        new_root,\n        {\n            new_child: child,\n            changed_nodes: []\n        }\n    ];\n}\n\nfunction addChild(parent: Node, child: Node): Node {\n    const children = getChildren(parent);\n\n    return parent.set(\"children\", children.push(child)) as Node;\n}\n\n/*\n  Update parent of updated-node; also update the parents of the parent\n\n  - 'old-child' is replaced by 'new-child'\n  - 'parents' are the parents of the child; direct parent first\n  - returns: [new root, affected]\n*/\nfunction updateParents(initial_old_child: Node, intitial_new_child: Node, parents: Node[]): [Node, Node[]] {\n    let old_child = initial_old_child;\n    let new_child = intitial_new_child;\n\n    const new_parents = parents.map(\n        parent => {\n            const new_parent = replaceChild(parent, old_child, new_child);\n\n            old_child = parent;\n            new_child = new_parent;\n\n            return new_parent;\n        }\n    );\n\n    return [\n        last(new_parents),\n        dropRight(new_parents)\n    ];\n}\n\nfunction replaceChild(node: Node, old_child: Node, new_child: Node): Node {\n    const { children } = node;\n    const child_index = children.indexOf(old_child);\n    const new_children = children.set(child_index, new_child);\n\n    return node.set(\"children\", new_children) as Node;\n}\n\n/*\n  Remove node\n  - return {new_root changed_nodes removed_nodes}\n*/\nexport function removeNode(readonly_child: IReadonlyNode): [Node, IRemoveInfo] {\n    const child = readonly_child.node;\n    const { parents } = readonly_child;\n    const parent = first(parents);\n\n    if (parent.is_root) {\n        return removeNodeFromRoot(parent, child);\n    }\n    else {\n        return removeNodeFromParent(parents, child);\n    }\n}\n\nfunction removeNodeFromRoot(root: Node, child: Node): [Node, IRemoveInfo] {\n    const new_root = removeChild(root, child);\n    const removed_nodes = Array.from(iterateTree(child, true));\n\n    return [\n        new_root,\n        {\n            changed_nodes: [],\n            removed_nodes\n        }\n    ];\n}\n\nfunction removeNodeFromParent(parents: Node[], child: Node): [Node, IRemoveInfo] {\n    const parent = first(parents);\n    const new_parent = removeChild(parent, child);\n    const [new_root, changed_parents] = updateParents(parent, new_parent, tail(parents));\n    const removed_nodes = Array.from(iterateTree(child, true));\n\n    return [\n        new_root,\n        {\n            changed_nodes: [new_parent].concat(changed_parents),\n            removed_nodes\n        }\n    ];\n}\n\nfunction removeChild(node: Node, child: Node): Node {\n    const children = getChildren(node);\n    const child_index = children.indexOf(child);\n    const new_children = children.delete(child_index);\n\n    return node.set(\"children\", new_children) as Node;\n}\n\nexport function updateNode(readonly_node: IReadonlyNode, attributes: any): [Node, IUpdateInfo] {\n    const { node, parents } = readonly_node;\n    const new_node = node.merge(attributes) as Node;\n    const [new_root, changed_parents] = updateParents(node, new_node, parents);\n\n    return [\n        new_root,\n        {\n            changed_nodes: [new_node].concat(changed_parents)\n        }\n    ];\n}\n"]}
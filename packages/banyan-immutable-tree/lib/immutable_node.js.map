{"version":3,"sources":["../src/immutable_node.ts"],"names":["create","toString","nodeListToString","hasChildren","getChildren","iterateTree","iterateTreeAndLevel","getNodeByName","doGetNodeByName","addNode","removeNode","updateNode","getNextNode","getPreviousNode","iterateTreeWithParents","createEmptyTree","createNode","is_root","data","createNodesFromData","parent_id","children_data","map","createNodeFromData","node_data","createChildren","children","id","set","nodesToString","nodes","join","node","has_children","isEmpty","get","name","n","treeSeqPath","is_branch","get_children","root","walk","path","toArray","new_path","push","child","parents","treeSeq","include_root","level","_","readonly_node","reverse","result","Error","readonly_parent","child_data","addNodeToNonRoot","addNodeToRoot","parent","new_child","new_parent","addChild","updateParents","new_root","changed_nodes","concat","initial_old_child","intitial_new_child","length","old_child","new_parents","replaceChild","child_index","indexOf","new_children","readonly_child","removeNodeFromRoot","removeNodeFromParent","removeChild","removed_nodes","Array","from","changed_parents","delete","attributes","new_node","merge","include_children","first","next_sibling","getNextSibling","getReadonlyParent","previous_sibling","getPreviousSibling","getLastChild","getChildIndex","index","last_child","last"],"mappings":"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","file":"immutable_node.js","sourcesContent":["import \"babel-polyfill\";\n\nimport { List, Map } from \"immutable\";\n\nimport { first, last, dropRight, tail } from \"lodash\";\n\ndeclare module \"immutable\" {\n    // tslint:disable-next-line: interface-name\n    interface List<T> {\n        [Symbol.iterator](): IterableIterator<T>;\n    }\n}\n\nexport type Node = Map<string, any>;\n\ntype GetChildren = (node: Node) => List<Node>;\ntype IsBranch = (node: Node) => boolean;\n\nexport type NodeId = number | string;\n\nexport interface INodeData {\n    id: NodeId;\n    name: string;\n    children?: INodeData[];\n    [key: string]: any;\n}\n\nexport interface IReadonlyNode {\n    node: Node;\n    parents: Node[];\n}\n\nexport interface IRemoveInfo {\n    changed_nodes: Node[];\n    removed_nodes: Node[];\n}\n\nexport interface IUpdateInfo {\n    changed_nodes: Node[];\n}\n\nexport interface IAddInfo {\n    new_child: Node;\n    changed_nodes: Node[];\n}\n\nconst createEmptyTree = (): Node => createNode({ is_root: true });\n\nconst createNode = (data: any) => (Map<string, any>(data) as any) as Node;\n\nconst createNodesFromData = (\n    parent_id: NodeId | null,\n    children_data: INodeData[]\n): List<Node> =>\n    List(\n        children_data.map(node_data => createNodeFromData(parent_id, node_data))\n    );\n\nfunction createNodeFromData(\n    parent_id: NodeId | null,\n    node_data: INodeData\n): Node {\n    function createChildren() {\n        if (!node_data.children) {\n            return null;\n        } else {\n            return createNodesFromData(node_data.id, node_data.children);\n        }\n    }\n\n    return (Map<string, any>(node_data)\n        .set(\"parent_id\", parent_id)\n        .set(\"children\", createChildren()) as any) as Node;\n}\n\nexport function create(children_data?: INodeData[]): Node {\n    function createChildren(): List<Node> {\n        if (children_data) {\n            return createNodesFromData(null, children_data);\n        } else {\n            return List<Node>();\n        }\n    }\n\n    return createEmptyTree().set(\"children\", createChildren()) as Node;\n}\n\nfunction nodesToString(nodes: List<Node>): string {\n    return nodes.map(toString).join(\" \");\n}\n\nexport function toString(node: Node): string {\n    const children = getChildren(node);\n    const has_children = !children.isEmpty();\n    const is_root = node.get(\"is_root\");\n    const name = node.get(\"name\");\n\n    if (is_root) {\n        if (!has_children) {\n            return \"\";\n        } else {\n            return nodesToString(children);\n        }\n    } else if (!has_children) {\n        return name;\n    } else {\n        return `${name}(${nodesToString(children)})`;\n    }\n}\n\nexport function nodeListToString(nodes: Node[]): string {\n    return nodes\n        .map(n => {\n            if (n.get(\"is_root\")) {\n                return \"[root]\";\n            } else {\n                return n.get(\"name\");\n            }\n        })\n        .join(\" \");\n}\n\nexport function hasChildren(node: Node): boolean {\n    const children = node.get(\"children\");\n\n    if (!children) {\n        return false;\n    } else {\n        return !children.isEmpty();\n    }\n}\n\nexport function getChildren(node: Node): List<Node> {\n    const children = node.get(\"children\");\n\n    if (children) {\n        return children;\n    } else {\n        return List<Node>();\n    }\n}\n\n/* Iterates over tree. Return [node parents] pairs.\n  - generator\n  - walks depth-first\n*/\nfunction treeSeqPath(\n    is_branch: IsBranch,\n    get_children: GetChildren,\n    root: Node\n): Iterable<[Node, Node[]]> {\n    function* walk(path: List<Node>, node: Node): Iterable<[Node, Node[]]> {\n        yield [node, path.toArray()];\n\n        if (is_branch(node)) {\n            const children = get_children(node);\n            const new_path = path.push(node);\n\n            for (const child of children) {\n                yield* walk(new_path, child);\n            }\n        }\n    }\n\n    return walk(List<Node>(), root);\n}\n\n// Iterate tree; return lazy sequence of readonly nodes\n// - skip root\nfunction* iterateTreeWithParents(root: Node): Iterable<IReadonlyNode> {\n    for (const [node, parents] of treeSeqPath(hasChildren, getChildren, root)) {\n        if (node !== root) {\n            yield { node, parents };\n        }\n    }\n}\n\nfunction treeSeq(\n    is_branch: IsBranch,\n    get_children: GetChildren,\n    root: Node,\n    include_root: boolean\n): Iterable<[Node, number]> {\n    function* walk(node: Node, level: number): Iterable<[Node, number]> {\n        if (node !== root || include_root) {\n            yield [node, level];\n        }\n\n        if (is_branch(node)) {\n            for (const child of get_children(node)) {\n                yield* walk(child, level + 1);\n            }\n        }\n    }\n\n    return walk(root, 0);\n}\n\nexport function* iterateTree(\n    root: Node,\n    include_root: boolean = false\n): Iterable<Node> {\n    for (const [node, _] of treeSeq(\n        hasChildren,\n        getChildren,\n        root,\n        include_root\n    )) {\n        yield node;\n    }\n}\n\nexport function* iterateTreeAndLevel(root: Node): Iterable<[Node, number]> {\n    yield* treeSeq(hasChildren, getChildren, root, false);\n}\n\n// Find node by name; return readonly node or nil\nexport function getNodeByName(root: Node, name: string): IReadonlyNode | null {\n    for (const readonly_node of iterateTreeWithParents(root)) {\n        if (readonly_node.node.get(\"name\") === name) {\n            const { node, parents } = readonly_node;\n\n            return {\n                node,\n                parents: parents.reverse()\n            };\n        }\n    }\n\n    return null;\n}\n\nexport function doGetNodeByName(root: Node, name: string): IReadonlyNode {\n    const result = getNodeByName(root, name);\n\n    if (!result) {\n        throw Error(`Node ${name} not found`);\n    }\n\n    return result;\n}\n\n// Add node\n//  - return [new-root {new-child changed-nodes}]\nexport function addNode(\n    root: Node,\n    readonly_parent: any,\n    child_data?: any\n): [Node, IAddInfo] {\n    if (child_data) {\n        return addNodeToNonRoot(readonly_parent, createNode(child_data));\n    } else {\n        const data = readonly_parent;\n        return addNodeToRoot(root, createNode(data));\n    }\n}\n\nfunction addNodeToNonRoot(\n    readonly_parent: IReadonlyNode,\n    child: Node\n): [Node, IAddInfo] {\n    const parent = readonly_parent.node;\n    const new_child = child.set(\"parent_id\", parent.get(\"id\")) as Node;\n    const new_parent = addChild(parent, new_child);\n    const [new_root, changed_nodes] = updateParents(\n        parent,\n        new_parent,\n        readonly_parent.parents\n    );\n\n    return [\n        new_root,\n        {\n            new_child,\n            changed_nodes: [new_parent].concat(changed_nodes)\n        }\n    ];\n}\n\nfunction addNodeToRoot(root: Node, child: Node): [Node, IAddInfo] {\n    const new_root = addChild(root, child);\n\n    return [\n        new_root,\n        {\n            new_child: child,\n            changed_nodes: []\n        }\n    ];\n}\n\nfunction addChild(parent: Node, child: Node): Node {\n    const children = getChildren(parent);\n\n    return parent.set(\"children\", children.push(child)) as Node;\n}\n\n/*\n  Update parent of updated-node; also update the parents of the parent\n\n  - 'old-child' is replaced by 'new-child'\n  - 'parents' are the parents of the child; direct parent first\n  - returns: [new root, affected]\n*/\nfunction updateParents(\n    initial_old_child: Node,\n    intitial_new_child: Node,\n    parents: Node[]\n): [Node, Node[]] {\n    if (parents.length === 0) {\n        throw new Error(\"updateParents: parents cannot be empty\");\n    }\n\n    let old_child = initial_old_child;\n    let new_child = intitial_new_child;\n\n    const new_parents = parents.map(parent => {\n        const new_parent = replaceChild(parent, old_child, new_child);\n\n        old_child = parent;\n        new_child = new_parent;\n\n        return new_parent;\n    });\n\n    return [last(new_parents) as Node, dropRight(new_parents) as Node[]];\n}\n\nfunction replaceChild(node: Node, old_child: Node, new_child: Node): Node {\n    const children = getChildren(node);\n    const child_index = children.indexOf(old_child);\n    const new_children = children.set(child_index, new_child);\n\n    return node.set(\"children\", new_children) as Node;\n}\n\n/*\n  Remove node\n  - return {new_root changed_nodes removed_nodes}\n*/\nexport function removeNode(readonly_child: IReadonlyNode): [Node, IRemoveInfo] {\n    const child = readonly_child.node;\n    const { parents } = readonly_child;\n    const parent = first(parents);\n\n    if (!parent) {\n        throw new Error(\"removeNode: child has no parent\");\n    }\n\n    if (parent.get(\"is_root\")) {\n        return removeNodeFromRoot(parent, child);\n    } else {\n        return removeNodeFromParent(parents, child);\n    }\n}\n\nfunction removeNodeFromRoot(root: Node, child: Node): [Node, IRemoveInfo] {\n    const new_root = removeChild(root, child);\n    const removed_nodes = Array.from(iterateTree(child, true));\n\n    return [\n        new_root,\n        {\n            changed_nodes: [],\n            removed_nodes\n        }\n    ];\n}\n\nfunction removeNodeFromParent(\n    parents: Node[],\n    child: Node\n): [Node, IRemoveInfo] {\n    const parent = first(parents);\n\n    if (!parent) {\n        throw new Error(\"removeNodeFromParent: parents cannot be empty\");\n    }\n\n    const new_parent = removeChild(parent, child);\n    const [new_root, changed_parents] = updateParents(\n        parent,\n        new_parent,\n        tail(parents)\n    );\n    const removed_nodes = Array.from(iterateTree(child, true));\n\n    return [\n        new_root,\n        {\n            changed_nodes: [new_parent].concat(changed_parents),\n            removed_nodes\n        }\n    ];\n}\n\nfunction removeChild(node: Node, child: Node): Node {\n    const children = getChildren(node);\n    const child_index = children.indexOf(child);\n    const new_children = children.delete(child_index);\n\n    return node.set(\"children\", new_children) as Node;\n}\n\nexport function updateNode(\n    readonly_node: IReadonlyNode,\n    attributes: any\n): [Node, IUpdateInfo] {\n    const { node, parents } = readonly_node;\n    const new_node = node.merge(attributes) as Node;\n    const [new_root, changed_parents] = updateParents(node, new_node, parents);\n\n    return [\n        new_root,\n        {\n            changed_nodes: [new_node].concat(changed_parents)\n        }\n    ];\n}\n\nexport function getNextNode(\n    readonly_node: IReadonlyNode,\n    include_children = true\n): Node | null {\n    const { node } = readonly_node;\n\n    if (include_children && hasChildren(node) && node.get(\"is_open\")) {\n        // First child\n        return getChildren(node).first();\n    } else {\n        const next_sibling = getNextSibling(readonly_node);\n\n        if (next_sibling) {\n            // Next sibling\n            return next_sibling;\n        } else {\n            const readonly_parent = getReadonlyParent(readonly_node);\n\n            if (!readonly_parent) {\n                return null;\n            } else {\n                return getNextNode(readonly_parent, false);\n            }\n        }\n    }\n}\n\nfunction getReadonlyParent(node: IReadonlyNode): IReadonlyNode | null {\n    const { parents } = node;\n    const parent = first(parents);\n\n    if (!parent) {\n        return null;\n    } else {\n        return {\n            node: parent,\n            parents: tail(parents)\n        };\n    }\n}\n\nexport function getPreviousNode(readonly_node: IReadonlyNode): Node | null {\n    const previous_sibling = getPreviousSibling(readonly_node);\n\n    if (!previous_sibling) {\n        // Parent\n        const parent = first(readonly_node.parents);\n\n        if (!parent) {\n            throw new Error(\"Child has no parent\");\n        }\n\n        if (parent.get(\"is_root\")) {\n            return null;\n        } else {\n            return parent;\n        }\n    } else {\n        if (\n            !hasChildren(previous_sibling) ||\n            !previous_sibling.get(\"is_open\")\n        ) {\n            // Previous sibling\n            return previous_sibling;\n        } else {\n            // Last child of previous sibling\n            return getLastChild(previous_sibling);\n        }\n    }\n}\n\nfunction getChildIndex(parent: Node, child: Node): number | null {\n    const index = getChildren(parent).indexOf(child);\n\n    if (index === -1) {\n        return null;\n    } else {\n        return index;\n    }\n}\n\nfunction getNextSibling(readonly_node: IReadonlyNode): Node | null {\n    const { node, parents } = readonly_node;\n    const parent = first(parents);\n\n    if (!parent) {\n        return null;\n    } else {\n        const child_index = getChildIndex(parent, node);\n\n        if (child_index === null) {\n            return null;\n        } else {\n            return getChildren(parent).get(child_index + 1);\n        }\n    }\n}\n\nfunction getPreviousSibling(readonly_node: IReadonlyNode): Node | null {\n    const { node, parents } = readonly_node;\n    const parent = first(parents);\n\n    if (!parent) {\n        return null;\n    } else {\n        const child_index = getChildIndex(parent, node);\n\n        if (child_index === null || child_index === 0) {\n            return null;\n        } else {\n            return getChildren(parent).get(child_index - 1);\n        }\n    }\n}\n\nfunction getLastChild(node: Node): Node | null {\n    if (!hasChildren(node)) {\n        return null;\n    } else {\n        const last_child = getChildren(node).last();\n\n        if (!hasChildren(last_child) || !last_child.get(\"is_open\")) {\n            return last_child;\n        } else {\n            return getLastChild(last_child);\n        }\n    }\n}\n"]}
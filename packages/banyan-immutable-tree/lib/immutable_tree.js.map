{"version":3,"sources":["../src/immutable_tree.ts"],"names":["node","Tree","data","root","create","ids","createIdMap","selected","toString","getChildren","hasChildren","child","parent","addNodeToRoot","addNodeToParent","name","found_node","getNodeByName","doGetNodeByName","n","removeNode","getReadonlyNode","new_root","affected_info","updateTree","changed_nodes","removed_nodes","map","removed_node","get","id","result","getNodeById","Error","updateNode","is_open","Boolean","t","deselect","is_selected","isNodeOpen","closeNode","openNode","attributes","update_info","tree","iterateTree","level","iterateTreeAndLevel","node_level","keySeq","toArray","valueSeq","key","selected_node","getSelectedNode","selectNode","getPreviousNode","getNextNode","parent_id","addNode","new_child","readonly_parent","concat","parents","getParents","current_node","push","updated_nodes","deleted_ids","new_ids","updateIds","new_tree","createCopy","updates_node_map","merge","forEach","delete","iteratePairs"],"mappings":"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","file":"immutable_tree.js","sourcesContent":["import { List, Map } from \"immutable\";\n\nimport * as node from \"./immutable_node\";\nimport { Node, NodeId, INodeData, IReadonlyNode } from \"./immutable_node\";\n\nexport class Tree {\n    public root: Node;\n    private ids: Map<NodeId, Node>;\n    private selected: NodeId | null;\n\n    constructor(data: INodeData[] = []) {\n        this.root = node.create(data);\n        this.ids = createIdMap(this.root);\n\n        this.selected = null;\n    }\n\n    public toString(): string {\n        return node.toString(this.root);\n    }\n\n    public getChildren(): List<Node> {\n        return node.getChildren(this.root);\n    }\n\n    public hasChildren(): boolean {\n        return node.hasChildren(this.root);\n    }\n\n    public addNode(child: INodeData, parent?: Node): Tree {\n        if (!parent) {\n            return this.addNodeToRoot(child);\n        } else {\n            return this.addNodeToParent(parent, child);\n        }\n    }\n\n    public getNodeByName(name: string): Node | null {\n        const found_node = node.getNodeByName(this.root, name);\n\n        if (!found_node) {\n            return null;\n        } else {\n            return found_node.node;\n        }\n    }\n\n    public doGetNodeByName(name: string): Node {\n        return node.doGetNodeByName(this.root, name).node;\n    }\n\n    public removeNode(n: Node): Tree {\n        const [new_root, affected_info] = node.removeNode(\n            this.getReadonlyNode(n)\n        );\n\n        return this.updateTree(\n            new_root,\n            affected_info.changed_nodes,\n            affected_info.removed_nodes.map(removed_node =>\n                removed_node.get(\"id\")\n            )\n        );\n    }\n\n    public getNodeById(id: NodeId): Node | null {\n        return this.ids.get(id);\n    }\n\n    public doGetNodeById(id: NodeId): Node {\n        const result = this.getNodeById(id);\n\n        if (!result) {\n            throw Error(`Node with id '${id} not found`);\n        }\n\n        return result;\n    }\n\n    public openNode(id: NodeId): Tree {\n        const n = this.getNodeById(id);\n\n        if (!n) {\n            return this;\n        } else {\n            return this.updateNode(n, { is_open: true });\n        }\n    }\n\n    public closeNode(id: NodeId): Tree {\n        const n = this.getNodeById(id);\n\n        if (!n) {\n            return this;\n        } else {\n            return this.updateNode(n, { is_open: false });\n        }\n    }\n\n    public isNodeOpen(id: NodeId): boolean {\n        const n = this.getNodeById(id);\n\n        if (!n) {\n            return false;\n        } else {\n            return Boolean(n.get(\"is_open\"));\n        }\n    }\n\n    public selectNode(id: NodeId): Tree {\n        const t = this.deselect();\n        const n = t.getNodeById(id);\n\n        if (!n) {\n            return t;\n        } else {\n            t.selected = id;\n            return t.updateNode(n, { is_selected: true });\n        }\n    }\n\n    public toggleNode(id: NodeId): Tree {\n        if (this.isNodeOpen(id)) {\n            return this.closeNode(id);\n        } else {\n            return this.openNode(id);\n        }\n    }\n\n    public updateNode(n: Node, attributes: any): Tree {\n        const [new_root, update_info] = node.updateNode(\n            this.getReadonlyNode(n),\n            attributes\n        );\n\n        return this.updateTree(new_root, update_info.changed_nodes, []);\n    }\n\n    public openAllFolders(): Tree {\n        let tree: Tree = this;\n\n        for (const n of node.iterateTree(this.root)) {\n            tree = tree.openNode(n.get(\"id\"));\n        }\n\n        return tree;\n    }\n\n    public openLevel(level: number): Tree {\n        let tree: Tree = this;\n\n        for (const [n, node_level] of node.iterateTreeAndLevel(this.root)) {\n            if (node_level <= level) {\n                tree = tree.openNode(n.get(\"id\"));\n            }\n        }\n\n        return tree;\n    }\n\n    public getSelectedNode(): Node | null {\n        if (!this.selected) {\n            return null;\n        } else {\n            return this.getNodeById(this.selected);\n        }\n    }\n\n    public getIds(): NodeId[] {\n        return this.ids.keySeq().toArray();\n    }\n\n    public getNodes(): Node[] {\n        return this.ids.valueSeq().toArray();\n    }\n\n    /*\n        Change selected node based on key code.\n\n        Returns [ is_handled, new_tree ]\n\n        ```\n        const [ is_handled, new_tree ] = tree.handleKey(\"ArrowDown\");\n        ```\n    */\n    public handleKey(key: string): [boolean, Tree] {\n        const selected_node = this.getSelectedNode();\n\n        if (!selected_node) {\n            return [false, this];\n        } else {\n            const selectNode = (n: Node | null) =>\n                n ? this.selectNode(n.get(\"id\")) : this;\n\n            switch (key) {\n                case \"ArrowUp\":\n                    return [\n                        true,\n                        selectNode(this.getPreviousNode(selected_node))\n                    ];\n\n                case \"ArrowDown\":\n                    return [true, selectNode(this.getNextNode(selected_node))];\n\n                case \"ArrowRight\":\n                    if (!node.hasChildren(selected_node)) {\n                        return [false, this];\n                    } else {\n                        const is_open = selected_node.get(\"is_open\");\n\n                        if (is_open) {\n                            // Right moves to the first child of an open node\n                            return [\n                                true,\n                                selectNode(this.getNextNode(selected_node))\n                            ];\n                        } else {\n                            // Right expands a closed node\n                            return [\n                                true,\n                                this.openNode(selected_node.get(\"id\"))\n                            ];\n                        }\n                    }\n\n                case \"ArrowLeft\":\n                    const is_open = selected_node.get(\"is_open\");\n\n                    if (node.hasChildren(selected_node) && is_open) {\n                        // Left on an open node closes the node\n                        return [true, this.closeNode(selected_node.get(\"id\"))];\n                    } else {\n                        // Left on a closed or end node moves focus to the node's parent\n                        const parent_id = selected_node.get(\"parent_id\");\n\n                        if (parent_id === null) {\n                            return [false, this];\n                        } else {\n                            return [true, this.selectNode(parent_id)];\n                        }\n                    }\n\n                default:\n                    return [false, this];\n            }\n        }\n    }\n\n    public getNextNode(n: Node): Node | null {\n        return node.getNextNode(this.getReadonlyNode(n));\n    }\n\n    public getPreviousNode(n: Node): Node | null {\n        return node.getPreviousNode(this.getReadonlyNode(n));\n    }\n\n    private addNodeToRoot(child: INodeData): Tree {\n        const [new_root, update_info] = node.addNode(this.root, child);\n\n        return this.updateTree(new_root, [update_info.new_child], []);\n    }\n\n    private addNodeToParent(parent: Node, child: INodeData): Tree {\n        const readonly_parent = this.getReadonlyNode(parent);\n        const [new_root, update_info] = node.addNode(\n            this.root,\n            readonly_parent,\n            child\n        );\n\n        return this.updateTree(\n            new_root,\n            update_info.changed_nodes.concat([update_info.new_child]),\n            []\n        );\n    }\n\n    private getReadonlyNode(n: Node): IReadonlyNode {\n        return {\n            node: n,\n            parents: this.getParents(n)\n        };\n    }\n\n    private getParents(n: Node): Node[] {\n        if (n.get(\"is_root\")) {\n            return [];\n        } else {\n            const parents: Node[] = [];\n            let current_node: Node | null = n;\n\n            while (current_node && current_node.get(\"parent_id\")) {\n                const parent: Node | null = this.getNodeById(\n                    current_node.get(\"parent_id\")\n                );\n\n                if (parent) {\n                    parents.push(parent);\n                }\n\n                current_node = parent;\n            }\n\n            parents.push(this.root);\n\n            return parents;\n        }\n    }\n\n    private updateTree(\n        new_root: Node,\n        updated_nodes: Node[],\n        deleted_ids: NodeId[]\n    ): Tree {\n        const new_ids = this.updateIds(updated_nodes, deleted_ids);\n\n        const new_tree = this.createCopy();\n\n        new_tree.ids = new_ids;\n        new_tree.root = new_root;\n\n        return new_tree;\n    }\n\n    private createCopy(): Tree {\n        const new_tree = new Tree();\n\n        new_tree.ids = this.ids;\n        new_tree.root = this.root;\n        new_tree.selected = this.selected;\n\n        return new_tree;\n    }\n\n    private updateIds(\n        updated_nodes: Node[],\n        deleted_ids: NodeId[]\n    ): Map<NodeId, Node> {\n        const updates_node_map = Map<NodeId, Node>(\n            updated_nodes.map((n: Node) => [n.get(\"id\"), n])\n        );\n\n        let new_ids = this.ids.merge(updates_node_map);\n\n        deleted_ids.forEach(id => {\n            new_ids = new_ids.delete(id);\n        });\n\n        return new_ids;\n    }\n\n    private deselect(): Tree {\n        if (!this.selected) {\n            return this;\n        } else {\n            const n = this.getNodeById(this.selected);\n\n            if (!n) {\n                return this;\n            } else {\n                const new_tree = this.updateNode(n, { is_selected: false });\n                new_tree.selected = null;\n\n                return new_tree;\n            }\n        }\n    }\n}\n\nfunction createIdMap(root: Node): Map<NodeId, Node> {\n    function* iteratePairs() {\n        for (const n of node.iterateTree(root)) {\n            yield [n.get(\"id\"), n];\n        }\n    }\n\n    return Map<NodeId, Node>(iteratePairs());\n}\n"]}